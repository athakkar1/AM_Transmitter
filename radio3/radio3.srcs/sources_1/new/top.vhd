LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
--use ieee.math_real.all;
--use ieee.std_logic_arith.all;
--use ieee.std_logic_unsigned.all;

ENTITY i2s_playback IS
    GENERIC(
        d_width     :  INTEGER := 16;
        points      :  INTEGER := 190;
        modpoints    :  INTEGER := 999;
        amp         :  INTEGER := 256
        );                    --data width
    PORT(
        clock       :  IN  STD_LOGIC;                     --system clock (100 MHz on Basys board)
        reset_n     :  IN  STD_LOGIC;                     --active low asynchronous reset
        adder       : IN STD_LOGIC;
        mclk        :  OUT STD_LOGIC;  --master clock
        sclk        :  OUT STD_LOGIC;  --serial clock (or bit clock)
        ws          :  OUT STD_LOGIC;  --word select (or left-right clock)
        sd_rx       :  IN  STD_LOGIC;                     --serial data in
        sclk_dac    :  out STD_LOGIC;
        ldac        :  OUT std_logic := '0';
        cs          :  out STD_LOGIC;
        sd_tx       :  OUT STD_LOGIC);                    --serial data out
END i2s_playback;

ARCHITECTURE logic OF i2s_playback IS
    
    SIGNAL master_clk   :  STD_LOGIC := '0';                             --internal master clock signal
    SIGNAL serial_clk   :  STD_LOGIC := '0';                      --internal serial clock signal
    SIGNAL word_select  :  STD_LOGIC := '0';                      --internal word select signal
    SIGNAL data_rx    :  STD_LOGIC_VECTOR(23 DOWNTO 0);  --left channel data received from I2S Transceiver component
    SIGNAL l_data_rx    :  STD_LOGIC_VECTOR(23 DOWNTO 0);  --left channel data received from I2S Transceiver component
    SIGNAL r_data_rx    :  STD_LOGIC_VECTOR(23 DOWNTO 0);  --left channel data received from I2S Transceiver component
    SIGNAL data_tx    :  STD_LOGIC_VECTOR(d_width-1 DOWNTO 0);  --right channel data to transmit using I2S Transceiver component    
    signal temp       : STD_LOGIC_VECTOR(23 DOWNTO 0);
    signal count : integer range 0 to 4 := 0; 
    signal sine_count : integer range 0 to 1000 := 0;
    signal j_count : integer range 0 to 1000 := 0;
    signal analog_input : std_logic_vector(15 downto 0) := (others => '0');
    signal modsig : std_logic_vector(15 downto 0) := (others => '0');
    signal i : integer range 0 to points := 0;
    signal j : integer range 0 to modpoints := 0;
    signal my_const : std_logic_vector(23 downto 0) := "000000000000000000000000";
type input_sig is array (0 to modpoints) of integer range 0 to amp;
type memory_type is array (0 to points) of integer range 0 to amp;
--ROM for storing the sine values generated by MATLAB.
signal sine : memory_type :=(128,132,136,140,144,148,153,157,
161,165,169,173,177,181,184,188,
192,195,199,202,206,209,212,215,
218,221,224,227,229,232,234,236,
239,241,243,244,246,247,249,250,
251,252,253,254,254,255,255,255,
255,255,255,254,254,253,252,251,
250,249,247,246,244,243,241,239,
236,234,232,229,227,224,221,218,
215,212,209,206,202,199,195,192,
188,184,181,177,173,169,165,161,
157,153,148,144,140,136,132,128,
123,119,115,111,107,102,98,94,
90,86,82,78,74,71,67,63,
60,56,53,49,46,43,40,37,
34,31,28,26,23,21,19,16,
14,12,11,9,8,6,5,4,
3,2,1,1,0,0,0,0,
0,0,1,1,2,3,4,5,
6,8,9,11,12,14,16,19,
21,23,26,28,31,34,37,40,
43,46,49,53,56,60,63,67,
71,74,78,82,86,90,94,98,
102,107,111,115,119,123,128);

signal modsine : input_sig := (128,128,129,130,131,132,132,133,
134,135,136,136,137,138,139,139,
140,141,142,143,143,144,145,146,
147,147,148,149,150,151,151,152,
153,154,155,155,156,157,158,158,
159,160,161,162,162,163,164,165,
165,166,167,168,168,169,170,171,
171,172,173,174,174,175,176,177,
177,178,179,180,180,181,182,183,
183,184,185,185,186,187,188,188,
189,190,190,191,192,192,193,194,
194,195,196,196,197,198,199,199,
200,200,201,202,202,203,204,204,
205,206,206,207,208,208,209,209,
210,211,211,212,212,213,214,214,
215,215,216,217,217,218,218,219,
219,220,220,221,222,222,223,223,
224,224,225,225,226,226,227,227,
228,228,229,229,230,230,231,231,
232,232,233,233,233,234,234,235,
235,236,236,236,237,237,238,238,
238,239,239,240,240,240,241,241,
241,242,242,243,243,243,244,244,
244,245,245,245,245,246,246,246,
247,247,247,247,248,248,248,249,
249,249,249,249,250,250,250,250,
251,251,251,251,251,252,252,252,
252,252,252,253,253,253,253,253,
253,253,254,254,254,254,254,254,
254,254,254,254,255,255,255,255,
255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,
255,254,254,254,254,254,254,254,
254,254,254,253,253,253,253,253,
253,253,252,252,252,252,252,252,
251,251,251,251,251,250,250,250,
250,249,249,249,249,249,248,248,
248,247,247,247,247,246,246,246,
245,245,245,245,244,244,244,243,
243,243,242,242,241,241,241,240,
240,240,239,239,238,238,238,237,
237,236,236,236,235,235,234,234,
233,233,233,232,232,231,231,230,
230,229,229,228,228,227,227,226,
226,225,225,224,224,223,223,222,
222,221,220,220,219,219,218,218,
217,217,216,215,215,214,214,213,
212,212,211,211,210,209,209,208,
208,207,206,206,205,204,204,203,
202,202,201,200,200,199,199,198,
197,196,196,195,194,194,193,192,
192,191,190,190,189,188,188,187,
186,185,185,184,183,183,182,181,
180,180,179,178,177,177,176,175,
174,174,173,172,171,171,170,169,
168,168,167,166,165,165,164,163,
162,162,161,160,159,158,158,157,
156,155,155,154,153,152,151,151,
150,149,148,147,147,146,145,144,
143,143,142,141,140,139,139,138,
137,136,136,135,134,133,132,132,
131,130,129,128,128,127,126,125,
124,123,123,122,121,120,119,119,
118,117,116,116,115,114,113,112,
112,111,110,109,108,108,107,106,
105,104,104,103,102,101,100,100,
99,98,97,97,96,95,94,93,
93,92,91,90,90,89,88,87,
87,86,85,84,84,83,82,81,
81,80,79,78,78,77,76,75,
75,74,73,72,72,71,70,70,
69,68,67,67,66,65,65,64,
63,63,62,61,61,60,59,59,
58,57,56,56,55,55,54,53,
53,52,51,51,50,49,49,48,
47,47,46,46,45,44,44,43,
43,42,41,41,40,40,39,38,
38,37,37,36,36,35,35,34,
33,33,32,32,31,31,30,30,
29,29,28,28,27,27,26,26,
25,25,24,24,23,23,22,22,
22,21,21,20,20,19,19,19,
18,18,17,17,17,16,16,15,
15,15,14,14,14,13,13,12,
12,12,11,11,11,10,10,10,
10,9,9,9,8,8,8,8,
7,7,7,6,6,6,6,6,
5,5,5,5,4,4,4,4,
4,3,3,3,3,3,3,2,
2,2,2,2,2,2,1,1,
1,1,1,1,1,1,1,1,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,1,1,1,
1,1,1,1,1,1,1,2,
2,2,2,2,2,2,3,3,
3,3,3,3,4,4,4,4,
4,5,5,5,5,6,6,6,
6,6,7,7,7,8,8,8,
8,9,9,9,10,10,10,10,
11,11,11,12,12,12,13,13,
14,14,14,15,15,15,16,16,
17,17,17,18,18,19,19,19,
20,20,21,21,22,22,22,23,
23,24,24,25,25,26,26,27,
27,28,28,29,29,30,30,31,
31,32,32,33,33,34,35,35,
36,36,37,37,38,38,39,40,
40,41,41,42,43,43,44,44,
45,46,46,47,47,48,49,49,
50,51,51,52,53,53,54,55,
55,56,56,57,58,59,59,60,
61,61,62,63,63,64,65,65,
66,67,67,68,69,70,70,71,
72,72,73,74,75,75,76,77,
78,78,79,80,81,81,82,83,
84,84,85,86,87,87,88,89,
90,90,91,92,93,93,94,95,
96,97,97,98,99,100,100,101,
102,103,104,104,105,106,107,108,
108,109,110,111,112,112,113,114,
115,116,116,117,118,119,119,120,
121,122,123,123,124,125,126,127);

    --declare PLL to create 11.29 MHz master clock from 100 MHz system clock
    --COMPONENT clk_wiz_0
       -- PORT(
         --   clk_in1     :  IN STD_LOGIC  := '0';
         --   clk_out1    :  OUT STD_LOGIC);
     --   END COMPONENT;

    --declare I2S Transceiver component
    COMPONENT rx IS
        GENERIC(
            mclk_sclk_ratio :  INTEGER := 4;    --number of mclk periods per sclk period
            sclk_ws_ratio   :  INTEGER := 64;   --number of sclk periods per word select period
            d_width         :  INTEGER := 24);  --data width
        PORT(
            reset_n     :  IN   STD_LOGIC;                              --asynchronous active low reset
            mclk        :  IN   STD_LOGIC;                              --master clock
            sclk        :  OUT  STD_LOGIC;                              --serial clock (or bit clock)
            ws          :  OUT  STD_LOGIC;                              --word select (or left-right clock)
            sd_rx       :  IN   STD_LOGIC;  
            l_data_rx  :  OUT  STD_LOGIC_VECTOR(d_width-1 DOWNTO 0);  --left channel data received
            r_data_rx  :  OUT  STD_LOGIC_VECTOR(d_width-1 DOWNTO 0);
            data_rx : OUT STD_LOGIC_VECTOR(d_width-1 downto 0)); --right channel data received
    END COMPONENT;
    
        COMPONENT tx IS
        GENERIC(
            mclk_sclk_ratio  :  INTEGER := 2;    --number of sclk periods per word select period
            sclk_cs_ratio : INTEGER := 34;
            d_width          :  INTEGER := 16);  --data width
        PORT(
            reset_n    :  IN   STD_LOGIC;                             --asynchronous active low reset
            mclk       :  IN   STD_LOGIC;                             --master clock
            sd_tx      :  OUT  STD_LOGIC;                             --serial data transmit
            cs         :  out STD_LOGIC;
            sclk_dac   :  out STD_LOGIC;    
            data_tx  :  IN   STD_LOGIC_VECTOR(d_width-1 DOWNTO 0));  --right channel data received
    END COMPONENT;
BEGIN

    --instantiate PLL to create master clock
    --i2s_clock: clk_wiz_0 
   -- PORT MAP(clk_in1 => clock, clk_out1 => master_clk);
  
    --instantiate I2S Transceiver component
    rx_0: rx
    GENERIC MAP(mclk_sclk_ratio => 4, sclk_ws_ratio => 64, d_width => 24)
    PORT MAP(reset_n => reset_n, mclk => master_clk, sclk => serial_clk, ws => word_select, sd_rx => sd_rx,
             l_data_rx => l_data_rx, r_data_rx => r_data_rx, data_rx => data_rx);
             
    tx_0: tx
    GENERIC MAP(mclk_sclk_ratio => 2, sclk_cs_ratio => 34, d_width => 16)
    PORT MAP(reset_n => reset_n, mclk => clock, sd_tx => sd_tx,
             data_tx => modsig, sclk_dac => sclk_dac, cs => cs);

  
    process begin  
      wait until rising_edge(clock);
      if (count<4) then
          count <= count+1;
      else
          count <= 0;
          master_clk <= not master_clk;
      end if; 
   end process;
   
   process 
   VARIABLE jc  :  INTEGER := 200;  --counter of master clocks during half period of serial clock
   variable data : unsigned(7 downto 0);
   begin
    wait until rising_edge(clock);
    if(adder = '1') then
    jc := 200;
    else
    jc := 100;
    end if;
    if(j_count < jc) then
        j_count <= j_count + 1;
    else
    j_count <= 0;
    --modsig <= std_logic_vector(to_unsigned((unsigned(data_tx(23 downto 16)) * modsine(j)), 16));
    IF(j = modpoints) THEN
    j <= 0;
    ELSE 
    j <= j+1;
    END IF;
    end if;
    if(sine_count < 0) then
        sine_count <= sine_count + 1;
    else
        sine_count <= 0;
        data := unsigned(data_tx(15 downto 8));
        modsig <= std_logic_vector(data * to_unsigned(sine(i), 8));
        analog_input <= std_logic_vector(to_unsigned(sine(i) * 256, 16));
        if(i = points) then
        i <= 0;
        else
        i <= i + 1;
        end if;
    end if;
    end process;
    mclk <= master_clk;  --output master clock to ADC
    sclk <= serial_clk;  --output serial clock (from I2S Transceiver) to ADC
    ws <= word_select;   --output word select (from I2S Transceiver) to ADC
    process(clock)
    VARIABLE signedint : SIGNED(23 downto 0);
    VARIABLE unsignedint : unsigned(23 downto 0);
    begin
    signedint := signed(data_rx);
    unsignedint := unsigned(signedint + 8388608);
    temp <= std_logic_vector(unsignedint);
    data_tx <= temp(23 downto 8);
    end process;
END logic;
